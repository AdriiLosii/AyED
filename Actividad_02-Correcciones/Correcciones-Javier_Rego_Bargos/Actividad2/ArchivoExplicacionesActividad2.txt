Estructura de datos y algoritmos

Ejercicio 1
Las dos primeras funciones, son utilizadas para designar que operadores tienen prioridad para pasar a prefija,
y luego se crea la función infija a prefija. Esta función string almacena los paréntesis para evitar problemas
y luego utiliza la función anterior para pasar a sufija, y esta será dada la vuelta, dándonos así la función prefija.

Ejercicio 2 y ejercicio 3
Para el dos, para que maneje más cifras, creamos una función llamada, crear cadena, que crea una cadena de caracteres
con todos los números que hay en ese rango. Luego, para el tres, utilizamos la función completa de evaluación sufija
para realizar las operaciones pedidas.

Ejercicio 4
Para añadir la clase concatenación, asignamos los tamaños de ambas colas a dos variables, que luego usaremos en 2
bucles for como el rango

Ejercicio 5
Para la simulación de este ejercicio, propongo varios ejemplos de simulación. La primera simulación de 3600 segundos
y 5 páginas por minuto. Esta simulación, nos deja ver tiempos de espera relativamente normales, y pocas tareas pendientes.
Si bajamos la calidad, haciendo 20 paginas por minuto, con menos segundos, el tiempo baja considerablemente, y no hay tareas
pendientes. El último caso, muy extremo, donde aumentamos la calidad de la impresión, vemos tiempos de espera enormes, y muchas
tareas pendientes. Por lo que, la respuesta al ejercicio sería, que no sería capaz de soportarla, aunque depende de la cantidad,
ya que este último caso es extremadamente exagerado.

Ejercicio 7
Este está comentado en el propio código

Ejercicio 8
Con las colas de prioridad importamos la clase nodo con una prioridad, que es la que nosotros introducimos y a partir de la
prioridad introducida el valor introducido se inserta en una posición u otra dependiendo del valor de la prioridad.

Ejercicio 9
La especificación informal está en el propio código

Ejercicio 10
Se implementa el método anexar, donde se unen dos listas no ordenadas mediante un puntero que une el último elemento de una y el primero de otra.

Ejercicio 11
Los elementos añadidos a la función son anexar(une dos listas no ordenadas mediante un puntero que une el último elemento de
una y el primero de otra), insertar( nos permite agregar un elemento en la posición que sea elegida), índice (señala la posición del ítem),
extraer(que extrae y muestra el último elemento de la lista) y extraer(pos), este último en vez de extraer y mostrar el último elemento de
la lista. Modificar(cambia un elemento de la lista por otro). Luego fin, primero, siguiente y anterior, indican el elemento que esté al final,
al principio, después del elemento y antes, respectivamente.

Ejercicio 12
Los métodos restantes a añadir son índice(para indicar la posición del ítem pedido), borrar(para eliminar un elemento de la lista),
extraer(que extrae y muestra el último elemento de la lista) y extraer(pos), este último en vez de extraer y mostrar el último elemento de la lista).
Además fueron añadidos los métodos del ejercicio anterior, explicados ya con anterioridad.

Ejercicio 13:
Si en la función de agregar de las listas no ordenadas cambiamos el orden de los pasos, estaríamos asignando primero la cabeza al nuevo ítem,
luego se le coloca un puntero y este puntero se estaría señalando a sí mismo por ser la cabeza. Normalmente, este proceso se ejecuta primero
colocando un puntero al ítem a añadir, luego se señala a la cabeza actual, y hace que la cabeza cambie a ser el nuevo elemento. De esta forma,
deja de ser una lista enlazada, y se rompe todo el conjunto, siento imposible añadir más elementos a la línea, pues el puntero está permanentemente señalando al mismo elemento.

Ejercicio 14
Para lograr que funcione este ejercicio se añade al constructor una variable contador. Luego en el método agregar hacemos que la variable
contador sea igual a la misma mas 1y hacemos lo contrario con el método extraer: contador =contador -1.
Y para el tamaño únicamente tenemos que devolver esa variable por lo que el método tamaño es de orden O(1).
